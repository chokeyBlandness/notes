### 题目描述

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给你 n ，请计算 F(n) 。

示例 1：
输入：3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
示例 2：
输入：4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3

提示：
0 <= n <= 30

### 解题思路一：递归

**原理：**把 f(n) 问题的计算拆分成 f(n-1)和 f(n−2) 两个子问题的计算，并递归，以 f(0) 和 f(1) 为终止条件。

**缺点：** 大量重复的递归计算，例如 f(n) 和 f(n - 1) 两者向下递归需要 **各自计算** f(n - 2) 的值。

```java
class Solution {
    public int fib(int n) {
        if(n <= 1)return n;
        return fib(n-1) + fib(n-2);
    }
}
```

### 解题思路二：记忆化递归

**原理：**在递归法的基础上，新建一个长度为 n 的数组，用于在递归时存储 f(0) 至 f(n) 的数字值，重复遇到某数字则直接从数组取用，避免了重复的递归计算。

**缺点：**记忆化存储需要使用 O(N) 的额外空间。

```java
class Solution {
    public int fib(int n) {
        if (n <= 1) return n;
        int[] f = new int[n+1];
        f[0] = 0;
        f[1] = 1;
        for (int i = 2; i < f.length; i++) {
            f[i] = -1;
        }
        return fib(n, f);
    }

    public int fib(int n, int[] f) {
        if (n <= 1) return f[n];
        if (f[n] != -1) {
            return f[n];
        } else {
            f[n] = (fib(n-1,f) + fib(n-2, f)) % 1000000007;
        }
        return f[n];
    }
}
```

### 解题思路三：动态规范

**原理：**已斐波那契数列性质 f(n+1) = f(n) + f(n - 1) 为转移方程。

**动态规划解析：**

- 状态定义： 设 dp 为一维数组，其中 dp[i] 的值代表 斐波那契数列第 i 个数字 。
  转移方程： dp[i + 1] = dp[i] + dp[i - 1] ，即对应数列定义 f(n + 1) = f(n) + f(n - 1) ；
- 初始状态： dp[0]=0, dp[1] = 1 ，即初始化前两个数字；
- 返回值： dp[n] ，即斐波那契数列的第 n 个数字。

**空间复杂度优化：**

> 若新建长度为 n 的 dp 列表，则空间复杂度为 O(N) 。

- 由于 dp 列表第 i 项只与第 i-1 和第 i−2 项有关，因此只需要初始化三个整形变量 sum, a, b ，利用辅助变量 sum 使 a,b 两数字交替前进即可（具体实现见代码）。
- 节省了 dp 列表空间，因此空间复杂度降至 O(1) 。

```java
class Solution {
    public int fib(int n) {
        int a = 0, b = 1, sum;
        for(int i = 0; i < n; i++){
            sum = a + b;
            a = b;
            b = sum;
        }
        return a;
    }
}
```

